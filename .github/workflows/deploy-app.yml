# .github/workflows/deploy-app.yml
# PHP 애플리케이션 배포 워크플로우 (server 폴더 변경시만 실행)

name: Deploy PHP Application

on:
  push:
    branches: [ main ]
    paths:
      - 'WALB/server/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'WALB/server/**'

env:
  PROJECT_NAME: "walb-app"
  
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # 워킹 디렉토리를 WALB로 설정
    defaults:
      run:
        working-directory: ./WALB
    
    permissions:
      id-token: write
      contents: read
    
    steps:
    # ===============================================
    # 소스코드 체크아웃
    # ===============================================
    - name: Checkout code
      uses: actions/checkout@v4
    
    # ===============================================
    # PHP 및 Composer 환경 설정
    # ===============================================
    - name: Set up PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.1'
        extensions: pdo, pdo_pgsql, mbstring, xml, zip, gd
        coverage: none
    
    - name: Validate Composer
      run: |
        echo "🔍 PHP 애플리케이션 검증 중..."
        if [ -f "server/composer.json" ]; then
          cd server
          composer validate --no-check-publish
          composer install --no-dev --optimize-autoloader --no-interaction
          echo "✅ Composer 검증 완료"
        else
          echo "ℹ️ Composer 파일이 없습니다. Docker 빌드만 실행합니다."
        fi
    
    # ===============================================
    # AWS 인증 (OIDC 방식)
    # ===============================================
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN_APP }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions-Application-${{ github.run_id }}

    # ===============================================
    # 기존 인프라 정보 조회
    # ===============================================
    - name: Get Infrastructure Resources
      run: |
        echo "🔍 기존 인프라 리소스 정보 조회 중..."
        
        # ECR 리포지토리 URI 조회
        ECR_REPO=$(aws ecr describe-repositories --repository-names ${PROJECT_NAME}-ecr --query 'repositories[0].repositoryUri' --output text 2>/dev/null || echo "")
        if [ -z "$ECR_REPO" ]; then
          echo "❌ ECR 리포지토리를 찾을 수 없습니다: ${PROJECT_NAME}-ecr"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "ECR_REPOSITORY=$ECR_REPO" >> $GITHUB_ENV
        echo "✅ ECR Repository: $ECR_REPO"
        
        # EKS 클러스터 이름 조회
        EKS_CLUSTER=$(aws eks describe-cluster --name walb-eks-cluster --query 'cluster.name' --output text 2>/dev/null || echo "")
        if [ -z "$EKS_CLUSTER" ] || [ "$EKS_CLUSTER" == "None" ]; then
          echo "❌ EKS 클러스터를 찾을 수 없습니다: ${PROJECT_NAME}-eks"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "EKS_CLUSTER_NAME=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "✅ EKS Cluster: $EKS_CLUSTER"
        
        # RDS 엔드포인트 조회
        RDS_ENDPOINT=$(aws rds describe-db-instances --query 'DBInstances[?DBName==`mydb`].Endpoint.Address' --output text 2>/dev/null || echo "")
        if [ -z "$RDS_ENDPOINT" ] || [ "$RDS_ENDPOINT" == "None" ]; then
          echo "❌ RDS 인스턴스를 찾을 수 없습니다"
          echo "먼저 인프라 배포가 필요합니다."
          exit 1
        fi
        echo "RDS_ENDPOINT=$RDS_ENDPOINT" >> $GITHUB_ENV
        echo "✅ RDS Endpoint: $RDS_ENDPOINT"
        
        # EKS 클러스터 상태 확인
        EKS_STATUS=$(aws eks describe-cluster --name $EKS_CLUSTER --query 'cluster.status' --output text)
        if [ "$EKS_STATUS" != "ACTIVE" ]; then
          echo "❌ EKS 클러스터가 활성 상태가 아닙니다: $EKS_STATUS"
          exit 1
        fi
        echo "✅ EKS Cluster Status: $EKS_STATUS"
    
    # ===============================================
    # ECR 로그인
    # ===============================================
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    # ===============================================
    # Docker 이미지 빌드 및 푸시
    # ===============================================
    - name: Build and push Docker image
      id: build-image
      run: |
        echo "🐳 Docker 이미지 빌드 중..."
        
        # Git 커밋 해시를 태그로 사용
        IMAGE_TAG=${{ github.sha }}
        IMAGE_URI=${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
        
        # server 폴더로 이동해서 Docker 빌드
        cd server
        docker build -t $IMAGE_URI .
        docker tag $IMAGE_URI ${{ env.ECR_REPOSITORY }}:latest
        
        echo "📤 ECR에 이미지 푸시 중..."
        docker push $IMAGE_URI
        docker push ${{ env.ECR_REPOSITORY }}:latest
        
        echo "✅ 이미지 푸시 완료: $IMAGE_URI"
        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

    - name: Test Database Connection via Bastion
      run: |
        # AWS CLI를 사용해서 리소스 정보 직접 조회
        PROJECT_NAME="walb-app"
        
        # RDS 엔드포인트 조회 (태그 기반)
        echo "🔍 RDS 인스턴스 조회 중..."
        DB_HOST=$(aws rds describe-db-instances \
          --query "DBInstances[?contains(keys(TagList[?Key=='Project']), 'Project') && TagList[?Key=='Project'].Value[0]=='${PROJECT_NAME}'].Endpoint.Address" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$DB_HOST" ]; then
          # 태그 조회가 안 되면 DB 이름으로 조회
          DB_HOST=$(aws rds describe-db-instances \
            --query "DBInstances[?DBName=='mydb'].Endpoint.Address" \
            --output text 2>/dev/null || echo "")
        fi
        
        # Bastion Host IP 조회 (태그 기반)
        echo "🔍 Bastion Host 조회 중..."
        BASTION_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${PROJECT_NAME}-bastion-host" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          # 태그로 안 되면 보안그룹으로 조회
          BASTION_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Component,Values=Bastion" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text 2>/dev/null || echo "")
        fi
        
        # DB 사용자명과 DB 이름 (하드코딩된 값 사용)
        DB_NAME="mydb"
        DB_USER="dbadmin"
        
        # Parameter Store에서 DB 패스워드 조회
        echo "🔍 DB 패스워드 조회 중..."
        DB_PASSWORD=$(aws ssm get-parameter \
          --name "/${PROJECT_NAME}/rds/master-password" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text 2>/dev/null || echo "")
        
        # 값 검증
        if [ -z "$DB_HOST" ] || [ "$DB_HOST" == "None" ]; then
          echo "❌ RDS 엔드포인트를 찾을 수 없습니다."
          echo "사용 가능한 RDS 인스턴스:"
          aws rds describe-db-instances --query "DBInstances[*].[DBInstanceIdentifier,Endpoint.Address,DBName]" --output table
          exit 1
        fi
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          echo "❌ Bastion Host를 찾을 수 없습니다."
          echo "실행 중인 EC2 인스턴스:"
          aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].[InstanceId,PublicIpAddress,Tags[?Key=='Name'].Value[0]]" \
            --output table
          exit 1
        fi
        
        if [ -z "$DB_PASSWORD" ]; then
          echo "❌ DB 패스워드를 Parameter Store에서 찾을 수 없습니다."
          exit 1
        fi
        
        echo "✅ DB Host: '$DB_HOST'"
        echo "✅ Bastion IP: '$BASTION_IP'"
        echo "✅ DB User: '$DB_USER'"
        echo "✅ DB Name: '$DB_NAME'"
        
        # SSH 키를 Parameter Store에서 가져오기
        echo "🔑 SSH 키 조회 중..."
        aws ssm get-parameter \
          --name "/${PROJECT_NAME}/bastion/ssh-private-key" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text > bastion_key.pem
        chmod 600 bastion_key.pem
        
        echo "🔍 SSH 연결 테스트 중..."
        # SSH 연결 테스트 (타임아웃 설정)
        if ! ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ec2-user@$BASTION_IP "echo 'SSH connection successful'" 2>/dev/null; then
          echo "❌ SSH 연결 실패. Bastion Host 상태 확인:"
          aws ec2 describe-instances \
            --filters "Name=tag:Component,Values=Bastion" \
            --query "Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress]" \
            --output table
          exit 1
        fi
        
        echo "🔗 SSH 터널을 통한 PostgreSQL 연결 테스트 중..."
        # SSH 터널을 통한 PostgreSQL 연결 테스트
        ssh -i bastion_key.pem -o StrictHostKeyChecking=no -o ExitOnForwardFailure=yes -L 5432:$DB_HOST:5432 ec2-user@$BASTION_IP -N &
        SSH_PID=$!
        
        # 터널 설정 대기
        sleep 10
        
        # PostgreSQL 클라이언트 설치 (필요한 경우)
        if ! command -v psql &> /dev/null; then
          echo "📦 PostgreSQL 클라이언트 설치 중..."
          sudo apt-get update && sudo apt-get install -y postgresql-client
        fi
        
        # 로컬 포트를 통해 RDS 연결 테스트
        if PGPASSWORD=$DB_PASSWORD psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c "SELECT 1;" 2>/dev/null; then
          echo "✅ 데이터베이스 연결 성공"
        else
          echo "❌ 데이터베이스 연결 실패"
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem
          exit 1
        fi
        
        # SSH 터널 종료 및 정리
        kill $SSH_PID 2>/dev/null
        rm -f bastion_key.pem
        
        echo "✅ 데이터베이스 연결 테스트 완료"
      env:
        PROJECT_NAME: "walb-app"
        
    # ===============================================
    # PostgreSQL 클라이언트 설치 및 스키마 적용
    # ===============================================
    - name: Apply Database Schema
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "🗄️ 데이터베이스 스키마 적용 중..."
        
        # PostgreSQL 클라이언트 설치
        sudo apt-get update && sudo apt-get install -y postgresql-client
        
        # 환경 변수 설정
        PROJECT_NAME="walb-app"
        DB_HOST="${{ env.RDS_ENDPOINT }}"
        DB_NAME="mydb"
        DB_USER="dbadmin"
        
        # Bastion Host IP 조회
        BASTION_IP=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=${PROJECT_NAME}-bastion-host" "Name=instance-state-name,Values=running" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text 2>/dev/null || echo "")
        
        if [ -z "$BASTION_IP" ] || [ "$BASTION_IP" == "None" ]; then
          echo "❌ Bastion Host를 찾을 수 없습니다."
          exit 1
        fi
        
        echo "🔍 연결 정보:"
        echo "  RDS 엔드포인트: $DB_HOST"
        echo "  Bastion IP: $BASTION_IP"
        echo "  DB 이름: $DB_NAME"
        echo "  DB 사용자: $DB_USER"
        
        # SSH 키를 Parameter Store에서 가져오기
        echo "🔑 SSH 키 가져오는 중..."
        aws ssm get-parameter \
          --name "/${PROJECT_NAME}/bastion/ssh-private-key" \
          --with-decryption \
          --query 'Parameter.Value' \
          --output text > bastion_key.pem
        chmod 600 bastion_key.pem
        
        # SSH 터널 생성 (백그라운드에서 실행)
        echo "🔗 SSH 터널 생성 중..."
        ssh -i bastion_key.pem \
            -o StrictHostKeyChecking=no \
            -o ExitOnForwardFailure=yes \
            -L 5432:$DB_HOST:5432 \
            ec2-user@$BASTION_IP \
            -N &
        SSH_PID=$!
        
        # 터널 설정 대기
        echo "⏳ SSH 터널 설정 대기 중..."
        sleep 15
        
        # SSH 터널 상태 확인
        if ! kill -0 $SSH_PID 2>/dev/null; then
          echo "❌ SSH 터널 생성 실패"
          rm -f bastion_key.pem
          exit 1
        fi
        
        echo "✅ SSH 터널 생성 완료"
        
        # 로컬 포트를 통해 RDS 연결 테스트
        echo "🔍 데이터베이스 연결 테스트 중..."
        if ! PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h localhost \
          -p 5432 \
          -U "$DB_USER" \
          -d "$DB_NAME" \
          -c "SELECT version();" \
          -v ON_ERROR_STOP=1 >/dev/null 2>&1; then
          echo "❌ 데이터베이스 연결 실패"
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem
          exit 1
        fi
        
        echo "✅ 데이터베이스 연결 성공"
        
        # 기존 테이블 확인
        echo "🔍 기존 테이블 확인 중..."
        EXISTING_TABLES=$(PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
          -h localhost \
          -p 5432 \
          -U "$DB_USER" \
          -d "$DB_NAME" \
          -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'posts', 'images', 'files');" \
          -v ON_ERROR_STOP=1 | tr -d ' ')
        
        if [ "$EXISTING_TABLES" -eq "0" ]; then
          echo "📝 스키마 파일 적용 중..."
          if PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h localhost \
            -p 5432 \
            -U "$DB_USER" \
            -d "$DB_NAME" \
            -f server/files/schema.sql \
            -v ON_ERROR_STOP=1; then
            echo "✅ 스키마 적용 완료"
          else
            echo "❌ 스키마 적용 실패"
            kill $SSH_PID 2>/dev/null
            rm -f bastion_key.pem
            exit 1
          fi

          echo "✅ 데이터베이스 연결 성공"

          # 기존 테이블 확인
          echo "🔍 기존 테이블 확인 중..."
          EXISTING_TABLES=$(PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
            -h localhost \
            -p 5432 \
            -U "$DB_USER" \
            -d "$DB_NAME" \
            -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'posts', 'images', 'files');" \
            -v ON_ERROR_STOP=1 | tr -d ' ')

          if [ "$EXISTING_TABLES" -eq "0" ]; then
            echo "📝 스키마 파일 적용 중..."
            if PGPASSWORD="${{ secrets.DB_PASSWORD }}" psql \
              -h localhost \
              -p 5432 \
              -U "$DB_USER" \
              -d "$DB_NAME" \
              -f server/files/schema.sql \
              -v ON_ERROR_STOP=1; then
              echo "✅ 스키마 적용 완료"
            else
              echo "❌ 스키마 적용 실패"
              kill $SSH_PID 2>/dev/null
              rm -f bastion_key.pem
              exit 1
            fi
          else
            echo "ℹ️ 테이블이 이미 존재합니다. 스키마 적용을 건너뜁니다."
          fi

          # 정리 작업
          echo "🧹 정리 작업 중..."
          kill $SSH_PID 2>/dev/null
          rm -f bastion_key.pem

          echo "✅ 데이터베이스 스키마 작업 완료"

      # ===============================================
      # kubectl 및 Helm 설치
      # ===============================================
      - name: Install kubectl and Helm
        run: |
          echo "🔧 kubectl 및 Helm 설치 중..."

          # kubectl 설치
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

          # Helm 설치
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

          echo "✅ kubectl 및 Helm 설치 완료"
          kubectl version --client
          helm version

      - name: Update kubeconfig for EKS
        run: |
          echo "🔧 EKS 클러스터 kubeconfig 업데이트 중..."

          # 현재 AWS 자격 증명 확인
          echo "🔍 현재 AWS 자격 증명 확인..."
          aws sts get-caller-identity

          # EKS 클러스터 이름 조회 (여러 방법 시도)
          echo "🔍 EKS 클러스터 조회 중..."

          # 방법 1: 클러스터 목록에서 첫 번째 조회
          EKS_CLUSTER_NAME=$(aws eks list-clusters --query 'clusters[0]' --output text 2>/dev/null || echo "")

          # 방법 2: 특정 이름으로 조회
          if [ -z "$EKS_CLUSTER_NAME" ] || [ "$EKS_CLUSTER_NAME" == "None" ]; then
            EKS_CLUSTER_NAME="walb-eks-cluster"
            echo "기본 클러스터 이름 사용: $EKS_CLUSTER_NAME"
          fi

          # 클러스터 존재 확인
          if ! aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
            echo "❌ EKS 클러스터 '$EKS_CLUSTER_NAME'를 찾을 수 없습니다."
            echo "사용 가능한 클러스터 목록:"
            aws eks list-clusters --region ${{ secrets.AWS_REGION }}
            exit 1
          fi

          echo "✅ EKS 클러스터: $EKS_CLUSTER_NAME"
          echo "EKS_CLUSTER_NAME=$EKS_CLUSTER_NAME" >> $GITHUB_ENV

          # 클러스터 상태 확인
          CLUSTER_STATUS=$(aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} --query 'cluster.status' --output text)
          echo "클러스터 상태: $CLUSTER_STATUS"

          if [ "$CLUSTER_STATUS" != "ACTIVE" ]; then
            echo "❌ 클러스터가 ACTIVE 상태가 아닙니다: $CLUSTER_STATUS"
            exit 1
          fi

          # kubeconfig 업데이트 (상세 로그 포함)
          echo "🔧 kubeconfig 업데이트 중..."
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name "$EKS_CLUSTER_NAME" --verbose

          # 클러스터 연결 테스트 (자세한 오류 정보 포함)
          echo "🔍 클러스터 연결 테스트..."
          if ! kubectl cluster-info --request-timeout=30s; then
            echo "❌ kubectl cluster-info 실패. 추가 진단 정보:"
            
            # kubectl 설정 확인
            echo "kubectl 설정 확인:"
            kubectl config view
            
            # 현재 컨텍스트 확인
            echo "현재 컨텍스트:"
            kubectl config current-context
            
            # 클러스터 엔드포인트 직접 테스트
            CLUSTER_ENDPOINT=$(aws eks describe-cluster --name "$EKS_CLUSTER_NAME" --region ${{ secrets.AWS_REGION }} --query 'cluster.endpoint' --output text)
            echo "클러스터 엔드포인트: $CLUSTER_ENDPOINT"
            
            # IAM 역할과 RBAC 매핑 확인
            echo "EKS 클러스터의 aws-auth ConfigMap 확인이 필요할 수 있습니다."
            exit 1
          fi

          echo "🔍 노드 상태 확인..."
          kubectl get nodes --show-labels

      # ===============================================
      # AWS Load Balancer Controller 확인
      # ===============================================
      - name: Check AWS Load Balancer Controller
        run: |
          echo "🔍 AWS Load Balancer Controller 상태 확인 중..."
          
          # AWS Load Balancer Controller Pod 확인
          if kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller >/dev/null 2>&1; then
            echo "✅ AWS Load Balancer Controller Pod 발견"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
          else
            echo "❌ AWS Load Balancer Controller를 찾을 수 없습니다."
            echo "Terraform으로 AWS Load Balancer Controller를 먼저 설치해주세요."
            exit 1
          fi
          
          # IngressClass 확인
          if kubectl get ingressclass alb >/dev/null 2>&1; then
            echo "✅ IngressClass 'alb' 확인됨"
            kubectl get ingressclass alb
          else
            echo "❌ IngressClass 'alb'를 찾을 수 없습니다."
            echo "사용 가능한 IngressClass:"
            kubectl get ingressclass
            exit 1
          fi
          
          # ValidatingAdmissionWebhook 확인
          if kubectl get validatingwebhookconfigurations | grep -E "(vingress|aws-load-balancer)" >/dev/null 2>&1; then
            echo "✅ ValidatingWebhookConfiguration 확인됨"
            kubectl get validatingwebhookconfigurations | grep -E "(vingress|aws-load-balancer)"
          else
            echo "⚠️ ValidatingWebhookConfiguration을 찾을 수 없습니다."
            echo "AWS Load Balancer Controller가 아직 완전히 준비되지 않았을 수 있습니다."
          fi
          
          echo "✅ AWS Load Balancer Controller 확인 완료 - Ingress 기반 ALB 생성 준비됨"

      # ===============================================
      # Kubernetes 매니페스트 파일 생성
      # ===============================================
      - name: Generate Kubernetes manifests
        run: |
          echo "📝 Kubernetes 매니페스트 생성 중..."

          # Namespace 생성
          cat <<EOF > namespace.yaml
          apiVersion: v1
          kind: Namespace
          metadata:
            name: ${{ env.PROJECT_NAME }}
        EOF
        
        # ConfigMap 생성 (환경변수)
        cat <<EOF > configmap.yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: ${{ env.PROJECT_NAME }}-config
          namespace: ${{ env.PROJECT_NAME }}
        data:
          DB_HOST: "${{ env.RDS_ENDPOINT }}"
          DB_PORT: "5432"
          DB_NAME: "mydb"
          DB_USER: "dbadmin"
          AWS_REGION: "${{ secrets.AWS_REGION }}"
          AWS_S3_BUCKET: "walb-app-files"
          AWS_S3_REGION: "${{ secrets.AWS_REGION }}"
          STORAGE_TYPE: "s3"
          APP_ENV: "production"
          APP_DEBUG: "false"
          PHP_MEMORY_LIMIT: "256M"
          PHP_MAX_EXECUTION_TIME: "30"
          PHP_TIMEZONE: "Asia/Seoul"
          UPLOAD_MAX_SIZE: "10M"
          SESSION_LIFETIME: "7200"
        EOF
        
        # Secret 생성 (DB 패스워드)
        cat <<EOF > secret.yaml
        apiVersion: v1
        kind: Secret
        metadata:
          name: ${{ env.PROJECT_NAME }}-secret
          namespace: ${{ env.PROJECT_NAME }}
        type: Opaque
        data:
          DB_PASSWORD: $(echo -n "${{ secrets.DB_PASSWORD }}" | base64)
        EOF
        
        # Deployment 생성
        cat <<EOF > deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${{ env.PROJECT_NAME }}-app
          namespace: ${{ env.PROJECT_NAME }}
          labels:
            app: ${{ env.PROJECT_NAME }}-app
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: ${{ env.PROJECT_NAME }}-app
          template:
            metadata:
              labels:
                app: ${{ env.PROJECT_NAME }}-app
            template:
              metadata:
                labels:
                  app: ${{ env.PROJECT_NAME }}-app
              spec:
                serviceAccountName: ${{ env.PROJECT_NAME }}-service-account
                containers:
                - name: php-app
                  image: ${{ steps.build-image.outputs.image }}
                  ports:
                  - containerPort: 80
                    name: http
                  envFrom:
                  - configMapRef:
                      name: ${{ env.PROJECT_NAME }}-config
                  - secretRef:
                      name: ${{ env.PROJECT_NAME }}-secret
                  livenessProbe:
                    httpGet:
                      path: /healthcheck.php
                      port: 80
                    initialDelaySeconds: 60
                    periodSeconds: 30
                    timeoutSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /healthcheck.php
                      port: 80
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  securityContext:
                    runAsNonRoot: false
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: false
          EOF

          # Service 생성 (Ingress 기반이므로 ClusterIP 사용)
          cat <<EOF > service.yaml
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.PROJECT_NAME }}-service
            namespace: ${{ env.PROJECT_NAME }}
            labels:
              app: ${{ env.PROJECT_NAME }}-app
          spec:
            type: ClusterIP
            ports:
            - port: 80
              targetPort: 80
              protocol: TCP
              name: http
            selector:
              app: ${{ env.PROJECT_NAME }}-app
          EOF

          # Ingress 생성 (AWS Load Balancer Controller 사용)
          cat <<EOF > ingress.yaml
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.PROJECT_NAME }}-ingress
            namespace: ${{ env.PROJECT_NAME }}
            annotations:
              # AWS Application Load Balancer 설정
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
              
              # Health Check 설정 (PHP 애플리케이션)
              alb.ingress.kubernetes.io/healthcheck-path: /healthcheck.php
              alb.ingress.kubernetes.io/healthcheck-interval-seconds: '30'
              alb.ingress.kubernetes.io/healthcheck-timeout-seconds: '10'
              alb.ingress.kubernetes.io/healthy-threshold-count: '2'
              alb.ingress.kubernetes.io/unhealthy-threshold-count: '3'
              alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
              alb.ingress.kubernetes.io/healthcheck-port: '80'
              
              # Load Balancer 설정
              alb.ingress.kubernetes.io/load-balancer-name: ${{ env.PROJECT_NAME }}-ingress-alb
              alb.ingress.kubernetes.io/target-group-attributes: |
                stickiness.enabled=false,
                deregistration_delay.timeout_seconds=60,
                load_balancing.algorithm.type=round_robin,
                slow_start.duration_seconds=30
                
              # 태그 설정
              alb.ingress.kubernetes.io/tags: |
                Environment=${{ env.PROJECT_NAME }},
                Project=${{ env.PROJECT_NAME }},
                ManagedBy=Kubernetes,
                CreatedBy=AWS-Load-Balancer-Controller,
                Application=PHP-Blog
          spec:
            ingressClassName: alb
            rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: ${{ env.PROJECT_NAME }}-service
                      port:
                        number: 80
          EOF

          echo "✅ Ingress 기반 매니페스트 생성 완료"

          # ServiceAccount 생성 (IRSA용)
          cat <<EOF > serviceaccount.yaml
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: ${{ env.PROJECT_NAME }}-service-account
            namespace: ${{ env.PROJECT_NAME }}
            annotations:
              eks.amazonaws.com/role-arn: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/walb-app-eks-app-role
          EOF

          echo "✅ 매니페스트 파일 생성 완료"

      # ===============================================
      # EKS에 애플리케이션 배포 (main 브랜치일 때만)
      # ===============================================
      - name: Deploy to EKS
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "🚀 EKS에 애플리케이션 배포 중..."

          # Namespace 먼저 생성
          kubectl apply -f namespace.yaml

          # 나머지 리소스 배포
          kubectl apply -f serviceaccount.yaml
          kubectl apply -f configmap.yaml
          kubectl apply -f secret.yaml
          kubectl apply -f deployment.yaml
          kubectl apply -f service.yaml

          # Ingress 배포 (AWS Load Balancer Controller로 ALB 생성)
          echo "🔗 Ingress 리소스 배포 중..."
          
          # Ingress 배포
          echo "🚀 Ingress 배포 시작..."
          if kubectl apply -f ingress.yaml; then
            echo "✅ Ingress 리소스 생성 성공"
            
            # ALB 생성 대기
            echo "⏳ AWS Load Balancer Controller에 의한 ALB 생성 대기 중..."
            ALB_CREATED=false
            for i in {1..25}; do
              ALB_DNS=$(kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
              if [ -n "$ALB_DNS" ]; then
                echo "✅ ALB 생성 완료: $ALB_DNS"
                echo "ALB_HOSTNAME=$ALB_DNS" >> $GITHUB_ENV
                echo "DEPLOYMENT_METHOD=Ingress" >> $GITHUB_ENV
                ALB_CREATED=true
                break
              fi
              
              # 진행 상황 확인
              if [ $((i % 5)) -eq 0 ]; then
                echo "🔍 Ingress 상태 확인 (${i}/25)..."
                kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} || true
                kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} | grep -E "(Events|Address)" || true
              fi
              
              echo "ALB 생성 대기 중... ($i/25)"
              sleep 20
            done
            
            if [ "$ALB_CREATED" != "true" ]; then
              echo "⚠️ ALB 생성 시간 초과 - 상세 진단 실행"
              
              echo "🔍 Ingress 상세 상태:"
              kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} -o yaml || true
              kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }} || true
              
              echo "🔍 AWS Load Balancer Controller 로그:"
              kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=100 || true
              
              echo "DEPLOYMENT_METHOD=Ingress-Pending" >> $GITHUB_ENV
              echo "ALB_HOSTNAME=pending" >> $GITHUB_ENV
            fi
            
          else
            echo "❌ Ingress 배포 실패"
            echo "🔍 진단 정보:"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller
            kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=50 || true
            kubectl get validatingwebhookconfigurations | grep -E "(vingress|aws-load-balancer)" || echo "웹훅 없음"
            kubectl get ingressclass || true
            exit 1
          fi
          
          echo "✅ Ingress 기반 ALB 배포 완료"

          echo "⏳ 배포 완료 대기 중..."
          kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s

      # ===============================================
      # 배포 결과 확인
      # ===============================================
      - name: Verify Deployment
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "🔍 배포 상태 확인 중..."
          echo "네임스페이스: ${{ env.PROJECT_NAME }}"
          echo "앱 라벨: ${{ env.PROJECT_NAME }}-app"

          # 네임스페이스 존재 확인
          if ! kubectl get namespace ${{ env.PROJECT_NAME }} >/dev/null 2>&1; then
            echo "❌ 네임스페이스 '${{ env.PROJECT_NAME }}'가 존재하지 않습니다."
            kubectl get namespaces
            exit 1
          fi

          # 기본 리소스 상태 확인
          echo "📋 Pod 상태:"
          kubectl get pods -n ${{ env.PROJECT_NAME }} -o wide || echo "Pod를 찾을 수 없습니다."

          echo "📋 Service 상태:"
          kubectl get services -n ${{ env.PROJECT_NAME }} || echo "Service를 찾을 수 없습니다."

          echo "📋 Deployment 상태:"
          kubectl get deployments -n ${{ env.PROJECT_NAME }} || echo "Deployment를 찾을 수 없습니다."

          echo "📋 Ingress 상태:"
          kubectl get ingress -n ${{ env.PROJECT_NAME }} || echo "Ingress를 찾을 수 없습니다."

          echo "📋 AWS Load Balancer Controller 상태:"
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller || echo "AWS Load Balancer Controller를 찾을 수 없습니다."

          # Deployment 존재 확인 후 대기
          if kubectl get deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} >/dev/null 2>&1; then
            echo "⏳ Pod 준비 상태 대기 중..."
            kubectl wait --for=condition=ready pod -l app=${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s || echo "Pod 준비 상태 대기 시간 초과"
            
            echo "📝 Deployment 상세 정보:"
            kubectl describe deployment ${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }}
            
          else
            echo "❌ Deployment '${{ env.PROJECT_NAME }}-app'를 찾을 수 없습니다."
            echo "사용 가능한 Deployment 목록:"
            kubectl get deployments -n ${{ env.PROJECT_NAME }}
            exit 1
          fi

      # ===============================================
      # 배포 방법별 접속 URL 제공
      # ===============================================
      - name: Get Application URL
        if: success() && github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "🔗 애플리케이션 접속 정보 확인 중..."
          echo "배포 방법: ${DEPLOYMENT_METHOD:-Unknown}"

          if [ "${DEPLOYMENT_METHOD:-}" = "Ingress" ]; then
            echo "🔗 Ingress로 배포됨"
            echo "🌐 애플리케이션 접속 URL: http://${ALB_HOSTNAME:-확인불가}"
            
            echo "🔍 Ingress 상태:"
            kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}
            
          elif [ "${DEPLOYMENT_METHOD:-}" = "Ingress-Pending" ]; then
            echo "⚠️ Ingress ALB 생성이 진행 중입니다"
            echo "🔍 현재 Ingress 상태:"
            kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}
            kubectl describe ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}
            
            echo "🔍 AWS Load Balancer Controller 로그:"
            kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller --tail=20 || true
            
            echo "잠시 후 ALB가 생성되면 다음 명령어로 URL을 확인하세요:"
            echo "kubectl get ingress ${{ env.PROJECT_NAME }}-ingress -n ${{ env.PROJECT_NAME }}"
            
          else
            echo "❓ 배포 방법을 확인할 수 없습니다."
            echo "사용 가능한 서비스 확인:"
            kubectl get services -n ${{ env.PROJECT_NAME }}
            echo "사용 가능한 Ingress 확인:"
            kubectl get ingress -n ${{ env.PROJECT_NAME }}
          fi

          # 공통 디버깅 정보
          echo ""
          echo "📋 전체 리소스 상태:"
          kubectl get all -n ${{ env.PROJECT_NAME }}

      # ===============================================
      # 배포 완료 알림
      # ===============================================
      - name: Application Deployment Notification
        if: success() && github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "🎉 PHP 애플리케이션 배포 완료!"
          echo "프로젝트: ${{ env.PROJECT_NAME }}"
          echo "이미지: ${{ steps.build-image.outputs.image }}"
          echo "클러스터: ${{ env.EKS_CLUSTER_NAME }}"
          echo "네임스페이스: ${{ env.PROJECT_NAME }}"
          echo "데이터베이스: ${{ env.RDS_ENDPOINT }}"
          echo "커밋: ${{ github.sha }}"
          echo "배포 시간: $(date)"

          # 배포된 서비스 정보 출력
          echo "📋 배포된 리소스 목록:"
          kubectl get all -n ${{ env.PROJECT_NAME }} || echo "리소스 조회 실패"

      # ===============================================
      # 배포 실패 시 롤백
      # ===============================================
      - name: Rollback on failure
        if: failure() && github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          echo "❌ 배포 실패 - 이전 버전으로 롤백 중..."
          kubectl rollout undo deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} || true
          kubectl rollout status deployment/${{ env.PROJECT_NAME }}-app -n ${{ env.PROJECT_NAME }} --timeout=300s || true
          echo "✅ 롤백 시도 완료"
